<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml" dir="ltr">  <head>    <meta http-equiv="content-type" content="application/xhtml+xml; charset=iso-8859-1" />    <meta name="description" content="built-in oma2 help pages" />    <meta name="keywords" content="image processing" />    <meta name="author" content="oma developers" />    <link rel="stylesheet" type="text/css" href="Light/default.css" media="screen" />    <title>OMA2 Help</title>  </head>  <body>    <div class="container">      <div class="navigation">        <div class="title">          <h1>OMA2</h1>          <h2>- Help -</h2>        </div>        <a href="CommandIndex.html">Index</a> <a href="macro.html">Macro</a> <a          href="file.html">File</a>        <a href="display.html">Display</a> <a href="arithmetic.html">Processing</a>        <a href="index.html">First Steps</a>        <div class="clearer"><span></span></div>      </div>      <div class="holder">        <h1>Arithmetic and Image Processing Commands </h1>        <span style="font-weight: bold;">** Constant Arithmetic **</span><br />        + x<br />            Adds x to the data in the current image data buffer.<br />        <br />        +RGB x y z<br />            Adds x, y, and z to the red, green, and blue data in the current        image data buffer.<br />        <br />        - x<br />            Subtracts x from the data in the current image data buffer.<br />        <br />        -RGB x y z<br />            Subtracts x, y, and z from the red, green, and blue data in the        current image data buffer.<br />        <br />        * x<br />            Multiplies the data in the current image data buffer by x.<br />        <br />        *RGB x y z<br />            Multiply the red, green, and blue data in the current image data        buffer by x, y, and z.<br />        <br />        / x<br />            Divides the data in the current image data buffer by x.<br />        <br />        /RGB x y z<br />            Divide the red, green, and blue data in the current image data        buffer by x, y, and z.<br />        <br />        ^ x<br />            Raises the data in the current image data to the power x.<br />        <br />        ^RGB x y z<br />            Raise the red, green, and blue data in the current image data buffer        to the power x, y, and z.<br />        <br />        <br />        <span style="font-weight: bold;">** File and Temporary Image Arithmetic          **</span><br />        <br />        ADDFILE &lt;filename&gt;<br />        Adds the contents of an OMA file of a given name to the data in the        current image data buffer.<br />        <br />        DIVFILE &lt;filename&gt;<br />        Divides the data in the current buffer by the contents of the specified        file.<br />        <br />        MULFILE &lt;filename&gt;<br />        Multiplies the contents of the current data buffer by the contents of        the specified file.<br />        <br />        SUBFILE &lt;filename&gt;<br />        Subtracts the contents of the specified file from the data in the        current buffer.<br />        <br />        COMPOSITE  &lt;filename&gt;<br />            Create a composite image by appending the data in the specified file        to that which exists in the current image buffer. The width of the        specified file must be the same as that of the current image. <br />        <br />        ADDTMPIMAGE name<br />        Adds the contents of the named temporary image to the data in the        current image data buffer.<br />        <br />        DIVTMPIMAGE name<br />        Divides the data in the current buffer by the contents of the named        temporary image.<br />        <br />        MULTMPIMAGE name<br />        Multiplies the contents of the current data buffer by the contents of        the named temporary image.<br />        <br />        SUBTMPIMAGE name<br />        Subtracts the contents of the named temporary image from the data in the        current buffer.<br />        <br />        COMTEMPIMAGE name <br />            Create a composite image by appending the data in the named        temporary image to that which exists in the current image buffer. The        width of the specified temporary image be the same as that of the        current image.<br />        <br />        FTEMPIMAGE tempImage<br />            Free memory associated with temporary image tempImage. tempImage        must be in the range 0-9, or correspond to a named image.<br />        <br />        GTEMPIMAGE name<br />            Get temporary image that has been previously saved using STEMP.<br />        <br />        LTEMPIMAGE <br />            List defined temporary images.<br />        <br />        STEMPIMAGE name<br />            Save current image as temporary image with specified name. The name        can be 0-9 or a text string beginning with a lower case letter. This can        be retrieved with GTEMP.<br />        <br />        <span style="font-weight: bold;">** Accumulator Arithmetic **</span><br />        <br />        ACCUMULATE<br />            Allocates and clears memory for an image accumulator buffer that can        be used to sum individual images. The size of the accumulator is        determined by the image size parameters when the accumulate command is        first given.<br />        <br />        ACADD<br />            Adds the current image data buffer to the accumulator buffer.<br />        <br />        ACDELETE<br />            Frees the memory associated with the accumulator. <br />        <br />        ACGET<br />            Moves the data from the accumulator buffer into the current image        data area. The previous contents of the image data buffer are destroyed.<br />        <br />        HDRACCUMULATE cutoffMax cutoffMin<br />            Allocates and clears memory for an HDR accumulator that can be used        to generate HDR images from a series of different exposures. The cuttoff        value should be less than the saturation value for the detector. Values        less than cutoffMin are not included; the default for cutoffMin is 0.        The size of the accumulator is determined by the image size parameters        when the accumulate command is first given. Be sure the exposure value        for the image is set (e.g., imported from a raw file or set using the        EXPOSURE command).<br />        <br />        HDRACADD<br />            Adds the current image data buffer to the HDR accumulator buffer.        Values greater than the cutoff are excluded and values are then        normalized by the exposure time.<br />        <br />        HDRACDELETE<br />            Frees the memory associated with the HDR accumulator.<br />        <br />        HDRACGET<br />            Calculates an HDR image based on the data in the HDR accumulator and        moves that to the current image. The previous contents of the image data        buffer are destroyed.<br />        <br />        HDRNUMGET<br />            Returns an image based on the data in the HDR counter, which has the        number of images that contribute to the HDR image at each pixel. This        "counter" image becomes the current image. The previous contents of the        image data buffer are destroyed.<br />        <br />        <span style="font-weight: bold;">** Variables and Simple Arithmetic **</span><br />        <br />        VARIABLES<br />        Lists currently defined variables and their values. Variables are        defined using simple arithmetic expressions, such as<br />        my_var = 10<br />        or<br />        y = my_var*2<br />        The values of variables are accessed from other commands using @my_var.        For example,<br />        + @my_var<br />        or<br />        save datfile_@4myvar<br />        As with loops, the end of a variable can be tagged by adding a '\' For        example,<br />        save datfile_@my_var\_corrected<br />        See also commands FLOAT and INTVARIABLE<br />        <br />        FLOAT variable_name<br />        Specifies that variable_name is to be used as a floating point variable.<br />        <br />        INTVARIABLE variable_name<br />        Specifies that variable_name is to be used as an integer variable. <br />        <br />        VARIABLES<br />            Lists currently defined variables and their values. Variables are        defined using simple arithmetic expressions, such as<br />            my_var = 10<br />            or<br />            y = my_var*2<br />            The values of variables are accessed from other commands using        @my_var. For example,<br />            + @my_var<br />            or<br />            save datfile_@4myvar<br />            As with loops, the end of a variable can be tagged by adding a '\'        For example,<br />            save datfile_@my_var\_corrected<br />            See also commands FLOAT, INTVARIABLE and VARCLEAR<br />        <br />        VARCLEAR<br />            Clears all user-defined variables.<br />        <br />        <br />        <span style="font-weight: bold;">** Image Processing and Image Format **</span><br />        <br />        ABEL<br />            Calculate the abel inversion using three-point abel inversion        operator Di,j. The index i,j start from 0. The formula followed Dasch        1992 (Applied Optics) which contains several typos. One correction is        done in function OP1 following  Martin's PhD thesis.<br />        <br />        ABELRECT rec_width [rec_y0 rec_y1]<br />            Sets the rectangle (of width rec_width) according to the centroid of        the image. If rec_y0 and rec_y1 are omitted, they are taken to be the        top and bottom of the image.<br />        <br />        ABELPREP clip_value [fill_value]<br />            Finds the maximum pixel value along horizontal lines in the image.        If that maximum is &lt; clip_value, the entire horizontal line is set to        fill_value. Default for fill_value is 0.<br />        <br />        BLOCK n [m]<br />            Group the image data into n x m blocks (rows x cols). This command        reduces the size of the data buffer. The values are summed, pending        implementation of the BLKAVE command. If the image is flagged as color,        the three color planes are treated separately.<br />        <br />        BIT8 [min] [max]<br />            Converts the file in the OMA image buffer to have a dynamic range of        0 to 255. That is, 8 unsigned bits per pixel. This conversion is        automatically done before saving the image buffer as a TIFF image. If        the optional min and max are specified, they are used for the scaling        rather than the min and max of the current image buffer.<br />        <br />        BIT16 [min] [max]<br />            Converts the file in the OMA image buffer to have a dynamic range of        0 to 65535. That is, 16 unsigned bits per pixel. This conversion is        automatically done before saving the image buffer as a TIFF image with        the SATIFFSCALED command. If the optional min and max are specified,        they are used for the scaling rather than the min and max of the current        image buffer.<br />        <br />        CLIP value<br />            Sets all data values in the current image buffer that are &gt; value        to value.<br />        <br />        CLIPBOTTOM clip_value<br />            For the current image, set pixels whose value is &lt; clip_value to        be equal to clip_value.<br />        <br />        CLIPFBOTTOM clip_fraction<br />            For the current image, set pixels whose value is &lt;        clip_fraction*image_max to be equal to clip_fraction*image_max.<br />        <br />        CLIPFRACTION fraction<br />            Clip data at a fraction of the maximum value. Fraction is a real        argument.<br />        <br />        CROP<br />            Use the current rectangle to crop the image in the buffer.<br />        <br />        COLUMNS n<br />            Resets the number of columns in the current image to n.<br />        <br />        COLORFLAG [value]<br />            If an argument is given, the IS_COLOR flag is set to 0 (flag = 0) or        1 (anything else). If no argument is given, the current value of the        color flag is printed.<br />        <br />        CLEARBADPIX<br />             Sets pixels tagged as bad to the value of their 8 nearest        neighbors. This will not work well if there are contiguous bad pixels. <br />        <br />        FINDBADPIX Counts<br />            Searches the current image buffer for pixels whose value is more        than "Counts" above that of its nearest eight neighbors. Those pixels        are tagged as hot pixels.<br />        <br />        READBADPIX filename<br />         Read in bad pixel data from a text file.<br />            Format is:<br />            # of bad pixels<br />            detector_width    detector_height<br />            bad_pix1_x<br />            bad_pix1_y<br />            bad_pix2_x<br />            bad_pix2_y<br />            .<br />            .<br />            .<br />        <br />        WRITEBADPIX filename<br />            Save bad pixel data to a text file.<br />            Format is:<br />            # of bad pixels<br />            detector_width    detector_height<br />            bad_pix1_x<br />            bad_pix1_y<br />            bad_pix2_x<br />            bad_pix2_y<br />            .<br />            .<br />            .<br />        <br />        CYL2<br />            Treat the data in the current image as a half cross section of a        cylindrically symmetric intensity distribution. The centerline is        assumed to be along the LHS of the image. An integrated image is        calculated by rotating the image  about the centerline. Does a parallel        projection.<br />        <br />        DIFFX<br />            Differentiate the data in the current image data buffer in the x        direction. <br />        <br />        DIFFY<br />            Differentiate the data in the current image data buffer in the y        direction.<br />        <br />        DOC2RGB c1 c2 c3 c4<br />            Treat the image in the current image buffer as a raw document        (output from the dcraw routine with options -d or -D selected) and        convert it to an RGB image. This is assumed to have a 2 x 2 color matrix        of R G B values in a Bayer pattern. c1 - c4 have values 0, 1 or 2,        corresponding to red, green, and blue. For example, if Bayer Matrix is:<br />            G B<br />            R G<br />            c1 - c4 should be 1 2 0 1<br />            Appropriate values depend on the specific camera. (See the output        from the GET command when reading raw files.)<br />        <br />        DOC2COLOR c1 c2 c3 c4 c5<br />            Treat the image in the current image buffer as a raw document (e.g.,        output from the dcraw routine with options -d or -D selected) and        convert it to an R, G, or B image. This is assumed to have a 2 x 2 color        matrix of R G B values in a Bayer pattern. c1 - c4 have values 0, 1 or        2, corresponding to red, green, and blue. For example if Bayer Matrix is<br />            G B<br />            R G<br />            c1 - c4 should be 1 2 0 1<br />            c5 is 0, 1, or 2 for conversion to red, green, or blue. Pixels        associated with non-selected colors have a value of 0. Doing a BLOCK 2 2        command after this command will remove the zeros. Blocking 2 by 2 on the        green channel will sum the two green pixels.<br />        <br />        DISP2RGB<br />         Convert the display image to rgb. Use this to turn a false color        intensity map into an RGB image or to modify a color image so the values        follow the display settings. Returned values are integers between 0 -        255.<br />        <br />        DCRAWARGS  [arguments]<br />            Allows the user to specify the arguments passed to the dcraw        routine, which decodes camera raw files to OMA format. Omitting the        argument lists the allowed arguments and gives the current argument        settings. The filename field is ignored.<br />        <br />        DX n<br />            Specifies the number of detector pixels (not display screen pixels)        to be grouped (or binned) in the X direction.<br />        <br />        DY n<br />            Specifies the number of detector pixels (not display screen pixels)        to be grouped (or binned) in the Y direction.<br />        <br />        EXTRA [index] [value]<br />            Add extra information to the current image in the form of a floating        point value. If no argument is given, the command lists extra values in        the current image buffer. Indexing starts at 1.<br />        <br />        FFT mode scale_factor<br />            mode = 0  return the magnitude scaled by scale_factor<br />            mode = 1  return the real part scaled by scale_factor<br />            mode = 2  return the imaginary part scaled by scale_factor<br />            mode = 3  return inverse - input is real part scaled by scale_factor<br />            mode = 4  return inverse - input is imaginary part scaled by        scale_factor<br />            mode = 5  return the log of the magnitude squared scaled by        scale_factor<br />            mode = 6  return the magnitude squared scaled by scale_factor<br />            mode = 7  return the autocorrelation scaled by scale_factor<br />            mode = 8  return inverse - input is a filter scaled by n<br />        <br />        FOLD fraction new_width<br />            Fold an image in half vertically. It is assumed to be symmetric        about some nearly vertical axis. The center of symmetry is found        separately for each row, except if there are dark regions at the top and        bottom of the image. For the dark regions, the average center of the        middle part of the image is used as the center of symmetry. Dark regions        are rows (at the top and bottom) whose values are all less than        fraction*image_max. x0,y0 and x1,y1 are coordinates of the top and        bottom of the dark region, center is the average center. These are        returned in command_return_1-5.<br />        <br />        FRAME NewWidth NewHeight [Value] [X0] [Y0]<br />            Put a "frame" around the current image. X0 and Y0 are the        coordinates of the start of the new image in the current image's        coordinate system. X0 and Y0 can be positive (will crop out some of the        current image) or negative (The new image will have a border with the        pixels containing the Value specified). If X0 or Y0 are not integers,        the routine will interpolate pixel values. Default Value is 0. Default        of X0 and Y0 center the old image in the frame.<br />        <br />        GAUSSIAN EdgeValue [x0 y0]<br />            Generate a Gaussian distribution centered at x0, y0. If x0, and y0,        are not specified, the distribution is centered. The maximum is 1. For a        centered distribution, EdgeValue specifies the value of the distribution        at the center edge.<br />            <br />        GREY2RGB [scaleRed scaleGreen scaleBlue]<br />            Turns a single plane image into a three plane RGB image. The        optional weighting factors are applied to each color plane.<br />         <br />        GRADIENT<br />            Find the magnitude of the gradient of the data in the current image        buffer. Use two pixels on either side of current pixel for gradient.<br />        <br />        GSMOOTH dx [dy]<br />            Gaussian Smoothing of the data. dx and dy are the smoothing size        parameters. If dy is omitted, it is taken as dx. dx and dy must be odd.        sigma_x = (dx-1)/3.5<br />        <br />        GNOISE mean rms [seed]<br />            Gaussian deviate generator using built-in random-number generator        followed by Box-Muller transform.<br />        <br />        INVERT<br />            Inverts the image in the current image data buffer, causing the        first data point to become the last data point.<br />        <br />        INTEGRATE direction_flag selection_flag do_average<br />            Sum up the data in the horizontal ( direction_flag=0 ) or vertical        (direction_flag=1)direction. The two-dimensional image becomes a single        line. If selection_flag=1, the subset of the image specified by the        selection rectangle is used. Possible cases are:<br />            direction_flag = 1 The result is an array in x; sum in y direction<br />            direction_flag = 0 The result is an array in y; sum in x direction<br />            selection_box = 1 A selection box specifies what region to sum<br />            selection_box = 0 Sum all channels or tracks <br />            do_average = 1 Average along the integrate direction (divide by box        size in integration direction)<br />            do_average = 0 Just sum, don't average<br />        <br />        INTFILL direction_flag selection_flag do_average<br />            This works like the INTEGRATE command but a two-dimensional image is        formed by duplicating the summed values. If selection_flag=1, the new        image will be the size of the currently defined rectangle.<br />        <br />        IM2SEQUENCE filename frames<br />            Save the current image as a sequence of images with the specified        number of frames. This type of data file can be used by the SEQ2HDR        command.<br />        <br />        KILLBOX [value]<br />            This command works on the region of the image that has been        specified with the RECT command or mouse. The contents of this region        are set to 'value'. Default for 'value' is 0.<br />        <br />        KWABEL n<br />            Uses analytic evaluation of integral required for abel inversion,        which involves a lot of evaluations of ln(x). n is a scale factor for        the image.<br />        <br />        LN<br />            Returns the natural log of the current image.<br />        <br />        LOOKUP fn_number <br />            Redefine the current image using the lookup table specified by a        tabulated function. Use GETFUNCT n filename before using this command.<br />        <br />        MAKNEW n m<br />            Change the resolution of the data in the current data buffer to be n        rows x m columns. Bilinear interpolation is performed.<br />        <br />        MASK&gt; value<br />         Create a mask based on values in the current image greater than or        equal to the specified value. Mask values are 0 or 1.<br />        <br />        MASK&lt; value<br />         Create a mask based on values in the current image less than the        specified value. Mask values are 0 or 1.<br />        <br />        GETMATCH parameterfile<br />        Load the file matching parameters contained in the text file        "parameterfile". The format of the file is as follows:<br />        x1_ref y1_ref x1_i1 y1_i1 x1_i2 y1_i2<br />        x2_ref y2_ref x2_i1 y2_i1 x2_i2 y2_i2<br />        image1_width image1_height<br />        image2_width image2_height<br />        <br />        MATCH image2_data_file<br />            This command is used to create matching image pairs from images        taken with different magnification, displacement, and rotation. The        first image is assumed to be in the current image buffer.        "image2_data_file" specifies the name of a file containing the second        image. The necessary image matching parameters are stored in an ASCII        text file and must be loaded with the GETMATCH command prior to        executing the MATCH command. The command creates two new images and        stores them in files named Match_1 and Match_2. Image 1 should be the        lower resolution of the two.<br />        <br />        MIRROR<br />            Form a left-right mirror image operation on the data in the current        data buffer.<br />        <br />        NOISE average rms [seed]<br />            Creates a noise image with the specified average and rms. See also        GNOISE.<br />        <br />        POSITVE<br />            Sets all negative values in the image buffer to 0.  Positive values        are unaffected.<br />        <br />        POWER y<br />            Raise the data in the current image buffer to the power y (float).<br />        <br />        RAMP<br />            Fill current image with a ramp from 0 to the number of number of        channels.<br />        <br />        RECTANGLE ulx uly lrx lry<br />            Specify a rectangle that calculations are to be done on. The        arguments are upper left x coordinate; upper left y coordinate; lower        right x; lower right y.<br />        <br />        RGB2RED<br />            Get the red channel of the current color image.<br />        <br />        RGB2GREEN<br />            Get the green channel of the current color image.<br />        <br />        RGB2BLUE<br />            Get the blue channel of the current color image.<br />        <br />        RGB2COLOR colorNumber<br />            Get the red, green, or blue channel of the current color image for        colorNumber = 1, 2, or 3.<br />        <br />        ROW n<br />            Resets the number of rows in the current image to n.<br />        <br />        ROTATE [value]<br />            Rotates the data in the current image buffer.  If no value is        specified, the image is rotated by 90 degrees. If a value is specified,        the image is rotated by the specified number of degrees (this may be a        real number).<br />        <br />        RNDOFF<br />            Round the DATAWORD values Down to the nearest integer value.<br />        <br />        RNDUP<br />            Round the DATAWORD values UP to the nearest integer value.<br />        <br />        SIZE rows cols <br />            Set the number of rows and columns of the current image and zero the        data.<br />        <br />        SINGRID radius<br />            Draw a grid from the sine function.<br />        <br />        SMOOTH [n,m]<br />            Performs an n x m smoothing operation on data in the current image        buffer.  If only n is specified, an n x n smoothing is done; with no        argument, a 2 x 2 smoothing is performed.  For the smoothing operation        to be perfectly centered on each data point, the arguments must be odd.        For Gaussian smoothing, use GSMOOTH.<br />        <br />        SEQ2HDR filename cutoff<br />            Convert a sequence of images with different exposures to an HDR        image. The file contains all images and must have information on        exposures stored in the EXTRA data (see the EXTRA command). This type of        file can be created by GigE cameras in oma2cam or can be created using        the CREATEFILE/CONCATENATEFILE/COLSEFILE commands. Note that all        exposure information must be entered in the extra space before        CREATEFILE is used to open the file. Image values larger thatn the        cutoff value will not be included and this should be close to the        detector saturation value.<br />        <br />        SEQ2IMAGE filename<br />            Open all frames of a sequence of images to a single image whose        height is NFRAMES*FRAMEHEIGHT.<br />        <br />        SHOTNOISE seed<br />            Treat the data as counts and add random root N noise to the data.<br />        <br />        SNR gsmoothx gsmoothy aveSize<br />            Calculate the signal/noise ratio of the image by first gaussian        smoothing the image by the specified amount, then dividing the smoothed        image by the original unsmoothed image. The SNR is taken to be the rms        deviation calculated over an aveSize x aveSize area (the average is        assumed to be 1)centered on each pixel.<br />        <br />        TSMOOTH<br />            Smooth radius based on x_dim = Temp[0], y_dim = Temp[1]. This is a        function that enables (Rectangular) smoothing of an image, with variable        filter size. It works basically like SMOOTH 13 13, say, but it takes the        x_dim and y_dim locally based on the values in the  Temporary buffers        T[0] and T[1]. It has been used to variably smooth an image based on the        local length scale which was modelled.<br />        <br />        WARP subpix<br />            Remaps an image coordinate system using bilinear geometric warping.<br />            x' = a00 + a01x + a10y + a11xy<br />            y' = b00 + b01x + b10y + b11xy<br />            The 8 parameters must first be read in with the WARPARAMS command.        The subpix value specifies subpixel resolution used (default is 0.2).        Without subpixel sampling, there would likely be holes in the warped        image.<br />        <br />        WARPARAMS &lt;filename&gt;<br />            Reads in 8 warp parameters from the specified file. The format of        the text file should be as follows:<br />            a00 a01 a10 a11<br />            b00 b01 b10 b11<br />        <br />        X0 n<br />            Specifies that the detector is to be read out starting at column n.<br />        <br />        Y0 n<br />            Specifies that the detector is to be read out starting at row n.<br />        <br />        <br />      </div>      <div class="footer">Brought to you by Developers of OMA<br />          </div>    </div>  </body></html>